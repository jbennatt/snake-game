package snake_game;

import java.awt.Color;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
//import java.io.DataInputStream;
//import java.io.DataOutputStream;
//import java.io.IOException;
//import java.net.Socket;
//import java.net.SocketAddress;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Random;
//import java.util.Scanner;

import javax.swing.JPanel;

//import high_score_server.HighScoreServer;
//import high_score_server.HighScoreUpdate;
//import login_password.DialogFrame;
import util.Strobable;
import util.Strobe;

/**
 * A snake game represents a grid of squares
 * 
 * @author Jared F. Bennatt
 *
 */
public class SnakeGame extends JPanel implements Strobable, KeyListener {
	/**
	 * generated by eclipse
	 */
	private static final long serialVersionUID = 1646999052646763198L;

	public static final int LEFT = 0;
	public static final int RIGHT = 1;
	public static final int DOWN = 2;
	public static final int UP = 3;
	public static final int STOP = 4;

	// private static final Color BG_COLOR = Color.white;
	private static final Color BG_COLOR = Color.black;
	// private static final Color BG_COLOR2 = Color.white;
	private static final Color SNAKE_COLOR = new Color(53, 222, 0);
	private static final Color PADDING_COLOR = new Color(0, 102, 26);
	private static final Color APPLE_COLOR = Color.red;

	private static final Color DEAD_SNAKE_COLOR = Color.decode("#C1C1C1");
	private static final Color DEAD_SNAKE_PADDING_COLOR = new Color(0, 0, 169);

	// public static final int HEADING_QUEUE_LENGTH = 4;
	private final Deque<Integer> headingQueue = new LinkedList<>();

	final Deque<SnakeSquare> snake = new LinkedList<>();
	private int length = 1;
	public final int dl;

	private int eating = 0;
	private int heading;

	private final SnakeSquare[][] board;
	public final int width, height;

	private final Random RAND = new Random(System.nanoTime());

	boolean alive = true;

	private final Strobe strobe;

	private long startTime = System.currentTimeMillis();
	private double time = 0.0;

	private final SnakeSquare head;
	SnakeSquare apple;

	public final int snakeWidth;
	public final int padding;
	public final int snakeSquare;

	final BufferedImage raster;
	private final Graphics g;

	// private GamePanel gamePanel;
	// private final DialogFrame getNameDialog = new DialogFrame("Your Name:",
	// false);

	public SnakeGame(final int width, final int height, final int i0, final int j0, final int dl, final double speed,
			final int snakeWidth, final int padding) {
		super();

		this.width = width;
		this.height = height;
		this.board = new SnakeSquare[width][height];

		this.snakeWidth = snakeWidth;
		this.padding = padding;

		this.snakeSquare = snakeWidth + 2 * padding;
		this.raster = new BufferedImage((width + 2) * snakeSquare, (height + 2) * snakeSquare,
				BufferedImage.TYPE_INT_RGB);
		this.g = raster.getGraphics();

		this.setPreferredSize(new Dimension((width + 2) * snakeSquare, (height + 2) * snakeSquare));
		this.addKeyListener(this);

		for (int i = 0; i < width; ++i)
			for (int j = 0; j < height; ++j) {
				final SnakeSquare square = new SnakeSquare(i, j);
				this.board[i][j] = square;
			}
		this.dl = dl;

		this.head = board[i0][j0];

		this.strobe = new Strobe(this, speed);
		reset();
	}

	public void reset() {
		clearBoard();

		eating = 0;
		snake.clear();
		snake.add(head);
		head.occupied = true;
		drawSnake(head);
		length = 1;

		this.heading = STOP;
		this.alive = true;

		addApple();
		drawApple(apple);

		time = 0;
		repaint();
		this.requestFocus();
	}

	private void clearBoard() {
		for (int i = 0; i < board.length; ++i)
			for (int j = 0; j < board[i].length; ++j) {
				board[i][j].occupied = false;
				board[i][j].apple = false;
			}

		g.setColor(SnakeParameters.PANEL_BG);
		g.fillRect(0, 0, raster.getWidth(), raster.getHeight());

		g.setColor(BG_COLOR);
		g.fillRect(snakeSquare, snakeSquare, raster.getWidth() - 2 * snakeSquare, raster.getHeight() - 2 * snakeSquare);
	}

	public void start() {
		strobe.start();
	}

	public SnakeSquare get(final int i, final int j) {
		return board[i][j];
	}

	public boolean alive() {
		return alive;
	}

	public double getTime() {
		return heading == STOP ? time : (System.currentTimeMillis() - startTime) / 1000.0;
	}

	public int getLength() {
		return length;
	}

	public synchronized void strobe() {
		// System.out.println(heading);
		// System.out.println("At beginning: " + length);
		// if not alive
		if (!alive)
			return;

		if (!headingQueue.isEmpty()) {
			if (heading == STOP)
				startTime = System.currentTimeMillis();

			int newHeading;
			while (!headingQueue.isEmpty()) {
				if (isValidHeading(newHeading = headingQueue.pollFirst())) {
					heading = newHeading;
					break;
				}
			}

			// final int newHeading = headingQueue.pollFirst();
			// if (length == 1)
			// heading = newHeading;
			// else {
			// switch (newHeading) {
			// case RIGHT:
			// heading = heading != LEFT ? newHeading : heading;
			// break;
			// case LEFT:
			// heading = heading != RIGHT ? newHeading : heading;
			// break;
			// case UP:
			// heading = heading != DOWN ? newHeading : heading;
			// break;
			// case DOWN:
			// heading = heading != UP ? newHeading : heading;
			// break;
			// }
			// }
		}
		final SnakeSquare head = snake.peek();
		SnakeSquare next = null;
		// first add to the front in the direction of heading
		switch (heading) {
		case RIGHT:
			// ran off board to the right
			if (head.i == width - 1) {
				stop(width, head.j);
				return;
			}
			// get next square
			next = board[head.i + 1][head.j];
			break;
		case LEFT:
			if (head.i == 0) {
				stop(-1, head.j);
				return;
			}
			next = board[head.i - 1][head.j];
			break;
		case UP:
			if (head.j == 0) {
				stop(head.i, -1);
				return;
			}
			next = board[head.i][head.j - 1];
			break;
		case DOWN:
			if (head.j == height - 1) {
				stop(head.i, height);
				return;
			}
			next = board[head.i][head.j + 1];
			break;
		case STOP:
			return;
		default:
			throw new RuntimeException("Heading unrecognized: " + heading);
		}

		// make sure it's not occupied
		if (next.occupied) {
			// be careful, if you run into the tail, but the tail will move
			// out of the way (not currently eating), then it's OK.
			if (next != snake.peekLast() || eating != 0) {
				stop(next.i, next.j);
				return;
			}
		}

		// delete tail first
		if (eating == 0) {
			final SnakeSquare tail = snake.pollLast();
			tail.occupied = false;
			deleteSnake(tail);
		} else {
			// decrement eating and don't move tail
			--eating;
		}

		// add to the front
		snake.addFirst(next);
		// set next square to be occupied
		next.occupied = true;
		drawSnake(next);

		// System.out.println(length);
		if (next.apple) {
			eating += dl;
			next.apple = false;
			length += dl;
			// System.out.println(length);
			addApple();
			drawApple(apple);
		}
	}

	private boolean isValidHeading(final int newHeading) {
		if (heading == newHeading)
			return false;
		switch (newHeading) {
		case RIGHT:
			return heading != LEFT;
		case LEFT:
			return heading != RIGHT;
		case UP:
			return heading != DOWN;
		case DOWN:
			return heading != UP;
		default:
			return true;
		}

	}

	private void stop(final int i, final int j) {
		alive = false;
		heading = STOP;
		time = (System.currentTimeMillis() - startTime) / 1000.0;
		headingQueue.clear();

		deadSnake(i, j);
		// checkHighScore();
	}

	/*
	 * private void checkHighScore() { try { final Socket client = new
	 * Socket(HighScoreServer.SERVER_IP, HighScoreServer.PORT); final
	 * DataOutputStream dos = new DataOutputStream(client.getOutputStream());
	 * final DataInputStream dis = new DataInputStream(client.getInputStream());
	 * 
	 * dos.writeInt(HighScoreServer.UPDATE_QUERY); dos.writeInt(length);
	 * dos.writeDouble(time);
	 * 
	 * final char response = dis.readChar();
	 * System.out.println("read response: " + response);
	 * 
	 * if (response == 'y') { System.out.println("trying to get name"); // get
	 * name for high scores then send it to server final String name =
	 * getNameDialog.getAnswer();
	 * 
	 * if (name.length() > HighScoreUpdate.MAX_NAME_LENGTH) {
	 * dos.writeInt(HighScoreUpdate.MAX_NAME_LENGTH); for (int i = 0; i <
	 * HighScoreUpdate.MAX_NAME_LENGTH; ++i) dos.writeChar(name.charAt(i)); }
	 * else { dos.writeInt(name.length()); for (final char c :
	 * name.toCharArray()) dos.writeChar(c); } } else { // it wasn't a high
	 * score, close socket connection after // you read server's response
	 * client.close(); } } catch (IOException e) { e.printStackTrace(); }
	 * 
	 * // gamePanel.showHighScores(); }
	 */
	// public void addGamePanel(final GamePanel gamePanel) {
	// this.gamePanel = gamePanel;
	// getNameDialog.setParent(gamePanel);
	// }

	public void setHeading(final int heading) {
		if (alive) {
			headingQueue.add(heading);
//			if (headingQueue.size() > HEADING_QUEUE_LENGTH)
//				headingQueue.pollFirst();
		}
	}

	private void addApple() {
		// keep going until you find an unoccupied square to put the apple in
		while (true) {
			final int i = RAND.nextInt(width);
			final int j = RAND.nextInt(height);

			if (!board[i][j].occupied) {
				board[i][j].apple = true;
				apple = board[i][j];
				return;
			}
		}
	}

	private void deleteSnake(final SnakeSquare square) {
		final int x0 = (square.i + 1) * snakeSquare;
		final int y0 = (square.j + 1) * snakeSquare;

		g.setColor(BG_COLOR);
		g.fillRect(x0, y0, snakeSquare, snakeSquare);
		repaint(x0, y0, snakeSquare, snakeSquare);
	}

	private void drawApple(final SnakeSquare square) {
		final int x0 = (square.i + 1) * snakeSquare;
		final int y0 = (square.j + 1) * snakeSquare;

		g.setColor(APPLE_COLOR);
		g.fillRect(x0, y0, snakeSquare, snakeSquare);
		repaint(x0, y0, snakeSquare, snakeSquare);
	}

	private void drawSnake(final SnakeSquare square) {
		final int x0 = (square.i + 1) * snakeSquare;
		final int y0 = (square.j + 1) * snakeSquare;
		g.setColor(PADDING_COLOR);
		g.fillRect(x0, y0, snakeSquare, snakeSquare);
		g.setColor(SNAKE_COLOR);
		g.fillRect(x0 + padding, y0 + padding, snakeSquare - 2 * padding, snakeSquare - 2 * padding);
		repaint(x0, y0, snakeSquare, snakeSquare);
	}

	private void deadSnake(final int i, final int j) {
		final int x0 = (i + 1) * snakeSquare;
		final int y0 = (j + 1) * snakeSquare;

		g.setColor(DEAD_SNAKE_PADDING_COLOR);
		g.fillRect(x0, y0, snakeSquare, snakeSquare);
		g.setColor(DEAD_SNAKE_COLOR);
		g.fillRect(x0 + padding, y0 + padding, snakeSquare - 2 * padding, snakeSquare - 2 * padding);
		repaint(x0, y0, snakeSquare, snakeSquare);
	}

	@Override
	public void keyPressed(KeyEvent key) {
		switch (key.getKeyCode()) {
		case KeyEvent.VK_DOWN:
		case KeyEvent.VK_S:
		case KeyEvent.VK_NUMPAD2:
		case KeyEvent.VK_KP_DOWN:
			setHeading(SnakeGame.DOWN);
			break;
		case KeyEvent.VK_UP:
		case KeyEvent.VK_W:
		case KeyEvent.VK_NUMPAD8:
		case KeyEvent.VK_KP_UP:
			setHeading(SnakeGame.UP);
			break;
		case KeyEvent.VK_LEFT:
		case KeyEvent.VK_A:
		case KeyEvent.VK_NUMPAD4:
		case KeyEvent.VK_KP_LEFT:
			setHeading(SnakeGame.LEFT);
			break;
		case KeyEvent.VK_RIGHT:
		case KeyEvent.VK_D:
		case KeyEvent.VK_NUMPAD6:
		case KeyEvent.VK_KP_RIGHT:
			setHeading(SnakeGame.RIGHT);
			break;
		}
	}

	@Override
	public void keyReleased(KeyEvent arg0) {

	}

	@Override
	public void keyTyped(KeyEvent key) {
	}

	@Override
	public void addNotify() {
		super.addNotify();
		this.requestFocus();
	}

	@Override
	public void paintComponent(final Graphics g) {
		g.drawImage(raster, 0, 0, raster.getWidth(), raster.getHeight(), null);
	}
}
